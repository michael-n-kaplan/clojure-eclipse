grammar org.maschinenstuermer.clojure.Clojure 
hidden (WSS,SL_COMMENT)

generate clojure "http://www.maschinenstuermer.org/clojure/Clojure"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

File:
	namespaces+=Namespace*|
	exprs+=Form*;

SimpleForm:
	SimpleLiteral|
	SpecialForm|
	ReaderMacro|
	Seq;
		
Form:
	SimpleForm|
	Literal;
		
QuotedForm:
	QuotedLiteral|
	ReaderMacro|
	QuotedDot|
	QuotedSeq;

QuotedSeq:
	QuotedList|
	QuotedVector|
	QuotedMap|
	QuotedSet;
	
QuotedList:
	{ List }
	'(' elements+=QuotedForm* ')';

QuotedVector:
	{ Vector }
	'[' elements+=QuotedForm* ']';
		
QuotedMap:
	{ Map }
	'{' (keys+=QuotedForm elements+=QuotedForm)* '}';
	
QuotedSet:
	{ Set }
	'#{' elements+=QuotedForm* '}';

QuotedLiteral:
	{ QuotedLiteral }
	( literal=SimpleLiteral|
	  type=Symbol ('/' member = N?)?);
	
SimpleLiteral:
	value='nil'|
	value=STRING|
	value=NUMBER|
	value=KEYWORD|
	value=CHAR|
	value=Boolean;
	
Literal:
	type=[types::JvmType|Symbol] ('/' member=[types::JvmFeature|NAME])?;
	
	
Boolean:
	"true"|"false";
	
ReaderMacro:
	Deref|
	ReaderLambda|
	ReaderMetaMacro|
	ReaderQuote|
	ReaderVar|
	Regex|
	SyntaxQuote|
	Unquote|
	UnquoteSplicing;
	
ReaderMetaMacro:
	ReaderMeta form=Form;
	
ReaderLambda:
	{ ReaderLambda }
	'#(' exprs+=Form* ')';
	
SpecialForm:
	Do|
	Dot|
	If|
	Import|
	Let|
	Loop|
	Meta|
	MonitorEnter|
	MonitorExit|
	New|
	Quote|
	Recur|
	SymbolDef|
	Throw|
	Try|
	Var;

SymbolDef:
	Def|
	Defn|
	DefnPriv|
	Defmacro|
	Fn;
	 
// Special forms

Def:
	'(' 'def' meta=ReaderMeta? name=Symbol init=Form? ')';
	
Defn:
	'(' 'defn' meta=ReaderMeta? name=Symbol doc=STRING? attributes=Map? body=Body ')';

DefnPriv:
	'(' 'defn-' meta=ReaderMeta? name=Symbol doc=STRING? attributes=Map? body=Body ')';

Defmacro:
	'(' 'defmacro' meta=ReaderMeta? name=Symbol doc=STRING? attributes=Map? body=Body ')';
	 
Deref:
	'@' form=Form;
	
Do:
	{ Do }
	'(' 'do' exprs+=Form* ')';

QuotedDot:
	'(' '.' args+=QuotedForm+ ')';
	
Dot:
	'(' '.' args+=Form+ ')';
	
Fn:
	{ Fn }
	('(' ('fn'|'fn*') meta=ReaderMeta? name=Symbol? body=Body ')');
	
If:
	'(' 'if' test=Form then=Form else=Form? ')';
	
Import:
	'(' 'import' ('\'' packages+=PackageImport )+ ')';

PackageImport:
	'(' package=Symbol classes+=Symbol* ')';
	
LexicalScope:
	Lambda|
	Let|
	Loop;
	
Let:
	{ Let }
	'(' 'let' '['(bindings+=Binding inits+=Form)*']' exprs+=Form* ')';
	
Loop:
	{ Loop }
	'(' 'loop' '['(bindings+=Binding inits+=Form)*']' exprs+=Form* ')';
	
Namespace:
	Ns|
	InNs;
	
Ns:
	'(' 'ns' meta=ReaderMeta? name=Symbol attributes=Map? 
		refs+=Reference* ')'
		exprs += Form*;

InNs:
	'(' 'in-ns' '\'' name=Symbol ')'
		exprs += Form*;

Reference:
{Reference}
	('(' ':import' packages+=PackageImport+ ')'|
	 '(' ':use' uses+=ModuleImport+ ')'|
	 '(' ':require' requires+=ModuleImport+ ')'|
	 '(' ':refer-clojure' (':exclude' '(' excludes+=Symbol+ ')')? ')');

ModuleImport:
	requires+=SymbolImport|
	libSpecs+=LibSpec|
	flags+=KEYWORD|
	prefixLists+=PrefixLib;
	
SymbolImport:
	'(' lib=Symbol fns+=Symbol* ')';
	
LibSpec:
	'[' lib=Symbol ':as' alias=Symbol ']';
	
PrefixLib:
	'(' prefix=Symbol libSpecs+=LibSpec+ ')';
	
Meta:
	'(' 'meta' data=Form ')';
	
ReaderMeta:
	'^' data=Form;

MonitorEnter:
	'(' 'monitor-enter' form=Form ')';
		
MonitorExit:
	'(' 'monitor-exit' form=Form ')';
		
New:
	'(' 'new' class=[types::JvmType|NAME] args+=Form*')';
	
Recur:
	{ Recur }
	'(' 'recur' exprs+=Form* ')';
	
ReaderQuote:
	'\'' form=QuotedForm;
	
Quote:
	'(' 'quote' form=QuotedForm ')';
		
Regex:
	'#' regex=STRING;
	
SyntaxQuote:
	'`' form=QuotedForm;
	
Throw:
	'(' 'throw' expr=Form ')';
	
Try:
	{ Try }
	'(' 'try' exprs+=Form* (catchClauses+=CatchClause)* finallyClause=FinallyClause? ')';
	
CatchClause:
	'(' 'catch' className=Symbol name=Symbol exprs+=Form* ')';
	
FinallyClause:
	{ FinallyClause }
	'(' 'finally' exprs+=Form* ')';
	
Unquote:
	'~' form=Form;
	
UnquoteSplicing:
	'~@' form=Form;
	
ReaderVar:
	('#\'' symbol=[SymbolDef|Symbol]);
	
Var:
	('(' 'var' symbol=[SymbolDef|Symbol] ')');

// Bindings
	
Binding:
	SimpleBinding |
	VectorBinding |
	MapBinding;

NameBinding:
	meta=ReaderMeta? (varArg?='&'|keyWord=KEYWORD)? name=Symbol;
			
SimpleBinding:
	bindings+=NameBinding;
	
VectorBinding:
	{ VectorBinding }
	'[' bindings+=Binding* ']';
	
MapBinding:
	{ MapBinding }
	'{' bindings+=KeyBinding* '}';

KeyBinding:
	binding+=Binding key += KEYWORD; 

// fn 
	
Body:
	lambdas+=Lambda | 
	('(' lambdas+=Lambda ')')+;
	
Lambda:
	{ Lambda }
	'[' bindings+=Binding* ']' exprs+=Form*;

// Sequences
	
Seq:
	Call|
	List|
	Vector|
	Map|
	Set;
	
Call:
	'(' target=CallTarget isNew?='.'? args+=Form* ')';
	

CallTarget:
	type=[types::JvmType|N] ('/' member=[types::JvmFeature|NAME])?;

List:
	{ List }
	'(' (elements+=SimpleForm elements+=Form*)? ')';

Vector:
	{ Vector }
	'[' elements+=Form* ']';
		
Map:
	{ Map }
	'{' (keys+=Form elements+=Form)* '}';
	
Set:
	{ Set }
	'#{' elements+=Form* '}';

// data type rules
	
Symbol:
	NAME|
	'catch'|
	'def'|'defn'|'defn-'|'defmacro'|'do'|
	'fn'|'fn*'|'finally'|
	'if'|'in-ns'|'import'|
	'let'|'loop'|
	'meta'|'monitor-enter'|'monitor-exit'|
	'ns'|'new'|
	'quote'|
	'throw'|'try'|
	'recur'|
	'var'|
	'/';

N:
	'/'|
	NAME;
	
// Terminals
	
terminal KEYWORD:
	':' NAME;
	
terminal NAME: 
	'&'? SYMBOL_START (SYMBOL_START|DIGIT|'.'|'&')* |'..';
		
terminal SYMBOL_START:
	'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'*'|'!'|'?'|'='|'#'|'<'|'>'|'%';

terminal NUMBER: 
	DIGIT+(('.' DIGIT*)|('r' DIGIT+))?'M'?;
	
terminal DIGIT:
	('0'..'9');
	
terminal STRING	: 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';
	
terminal CHAR:
	'\\' !(' '|'\t'|'\r'|'\n')+;
	
terminal WSS: 
	(' '|'\t'|'\r'|'\n'|',')+;
	
terminal SL_COMMENT: 
	';' !('\n'|'\r')* ('\r'? '\n')?;
		