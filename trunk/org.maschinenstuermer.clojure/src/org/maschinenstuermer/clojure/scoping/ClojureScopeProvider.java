/*
 * generated by Xtext
 */
package org.maschinenstuermer.clojure.scoping;

import static org.eclipse.xtext.scoping.Scopes.scopeFor;
import static org.maschinenstuermer.clojure.ClojureUtil.IS_DEF;
import static org.maschinenstuermer.clojure.ClojureUtil.IS_JVM_FEATURE_CLAZZ;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.URIConverter;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.AbstractScopeProvider;
import org.eclipse.xtext.util.IResourceScopeCache;
import org.eclipse.xtext.util.Tuples;
import org.maschinenstuermer.clojure.clojure.Binding;
import org.maschinenstuermer.clojure.clojure.Body;
import org.maschinenstuermer.clojure.clojure.Fn;
import org.maschinenstuermer.clojure.clojure.KeyBinding;
import org.maschinenstuermer.clojure.clojure.Lambda;
import org.maschinenstuermer.clojure.clojure.LexicalScope;
import org.maschinenstuermer.clojure.clojure.SimpleBinding;
import org.maschinenstuermer.clojure.clojure.SymbolRef;
import org.maschinenstuermer.clojure.clojure.VectorBinding;
import org.maschinenstuermer.clojure.clojure.util.ClojureSwitch;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.name.Named;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class ClojureScopeProvider extends AbstractScopeProvider {

	@Inject
	private IResourceScopeCache scopeCache;
	
	@Inject
	@Named(AbstractDeclarativeScopeProvider.NAMED_DELEGATE)
	private IScopeProvider delegate;

	@Inject
	private AbstractTypeScopeProvider typeScopeProvider;
	private Predicate<JvmMember> filter = new Predicate<JvmMember>() {

		@Override
		public boolean apply(final JvmMember input) {
			final EStructuralFeature staticAttribute = input.eClass().getEStructuralFeature("static");
			return staticAttribute != null && input.eGet(staticAttribute).equals(true);
		}
	};
	private Function<JvmMember, String> names = new Function<JvmMember, String>() {

		@Override
		public String apply(JvmMember from) {
			return from.getSimpleName();
		}
	};

	public void setDelegate(final IScopeProvider delegate) {
		this.delegate = delegate;
	}

	public IScopeProvider getDelegate() {
		return delegate;
	}

	@Override
	public IScope getScope(final EObject context, final EReference reference) {
		return scope(context, reference);
	}
	
	private IScope scope(final EObject context, 
			final EReference reference) {
		assert context != null;
		
		final Resource eResource = context.eResource();
		final Object readOnly = eResource.getResourceSet().getURIConverter().getAttributes(eResource.getURI(), null).get(URIConverter.ATTRIBUTE_READ_ONLY);
		final boolean isReadOnly = Boolean.TRUE.equals(readOnly);
		
		if (IS_JVM_FEATURE_CLAZZ.apply(reference.getEReferenceType())) {
			final SymbolRef symbolRef = (SymbolRef) context;
			return typeScopeProvider.createMemberScope(symbolRef.getType(), filter, names, IScope.NULLSCOPE);
		} else { 
			final LexicalScope lexicalScope = getLexicalScope(context);
			if (!isReadOnly && lexicalScope != null) {
				return lexicalScope(context, lexicalScope, reference);
			} else {
				return defScope(context, reference);
			}
		}
	}
	
	private IScope defScope(final EObject context, final EReference reference) {
		return scopeCache.get(Tuples.pair("def", null), context.eResource(), new Provider<IScope>() {
			@Override
			public IScope get() {
				final List<EObject> defs = Lists.newArrayList(Iterators.filter(getAllContents(context), IS_DEF));
				final IScope outerScope = delegateGetScope(context, reference);
				return outerScope == null ? 
						scopeFor(defs) : scopeFor(defs, outerScope);
			}
		});
	}

	private IScope lexicalScope(final EObject context,
			final LexicalScope lexicalScope, final EReference reference) {
		assert lexicalScope != null;
		
		return scopeCache.get(Tuples.pair("lexical", lexicalScope), context.eResource(), new Provider<IScope>() {
			@Override
			public IScope get() {
				final List<EObject> namesInScope = NameBindings.all(lexicalScope);
				final LexicalScope nextLexicalScope = getLexicalScope(lexicalScope.eContainer());
				final IScope outerScope = nextLexicalScope == null ? 
						defScope(context, reference) : scope(nextLexicalScope, reference);
				return scopeFor(namesInScope, outerScope);
			}
		});
	}
	
	private TreeIterator<EObject> getAllContents(final EObject context) {
		return EcoreUtil.getRootContainer(context).eAllContents();
	}
	
	private LexicalScope getLexicalScope(final EObject context) {
		EObject currentContext = context;
		while (!(currentContext instanceof LexicalScope) && currentContext != null) {
			currentContext = currentContext.eContainer();
		}
		return (LexicalScope) currentContext;
	}
	
	private IScope delegateGetScope(final EObject context, final EReference reference) {
		return getDelegate().getScope(context, reference);
	}
	
	private static class NameBindings extends ClojureSwitch<List<EObject>> {
		private final List<EObject> nameBindings = 
			new ArrayList<EObject>();
		
		public static List<EObject> all(final LexicalScope lexicalScope) {
			return new NameBindings().doSwitch(lexicalScope);
		}
		
		@Override
		public List<EObject> caseLambda(final Lambda object) {
			caseLexicalScope(object);
			final EObject eContainer = object.eContainer();
			if (eContainer instanceof Body && eContainer.eContainer() instanceof Fn) 
				nameBindings.add(eContainer.eContainer());
			
			return nameBindings;
		}
		
		@Override
		public List<EObject> caseLexicalScope(LexicalScope lexicalScope) {
			for(Binding binding : lexicalScope.getBindings())
				doSwitch(binding);
			return nameBindings;
		}
		
		@Override
		public List<EObject> caseSimpleBinding(final SimpleBinding simpleBinding) {
			nameBindings.addAll(simpleBinding.getBindings());
			return nameBindings;
		}
		
		@Override
		public List<EObject> caseKeyBinding(final KeyBinding keyBinding) {
			for (final Binding binding : keyBinding.getBinding()) 
				doSwitch(binding);
			
			return nameBindings;
		}
		
		@Override
		public List<EObject> caseVectorBinding(final VectorBinding vectorBinding) {
			for (final Binding binding : vectorBinding.getBindings()) 
				doSwitch(binding);
			
			return nameBindings;
		}
	}
}
