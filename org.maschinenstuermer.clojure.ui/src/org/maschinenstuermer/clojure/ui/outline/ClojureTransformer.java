/*
 * generated by Xtext
 */
package org.maschinenstuermer.clojure.ui.outline;

import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.ContentOutlineNode;
import org.eclipse.xtext.ui.editor.outline.transformer.AbstractDeclarativeSemanticModelTransformer;
import org.maschinenstuermer.clojure.ClojureUtil;
import org.maschinenstuermer.clojure.clojure.Form;
import org.maschinenstuermer.clojure.clojure.Namespace;
import org.maschinenstuermer.clojure.clojure.SymbolDef;

import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

/**
 * customization of the default outline structure
 * 
 */
public class ClojureTransformer extends AbstractDeclarativeSemanticModelTransformer {

	public ContentOutlineNode createNode(final Namespace namespace, final ContentOutlineNode parentNode) {
		final ContentOutlineNode node = super.newOutlineNode(namespace, parentNode);
		return node;
	}

	public List<EObject> getChildren(final Namespace parent) {
		return Lists.newArrayList(Iterables.filter(parent.eContents(), ClojureUtil.IS_DEF));
	}

	public List<EObject> getChildren(final Form parent) {
		return Lists.newArrayList(Iterables.filter(parent.eContents(), ClojureUtil.IS_DEF));
	}

//	public List<Key> getChildren(final Defstruct defstruct) {
//		return Lists.newArrayList(defstruct.getKeys());
//	}
//
//	public ContentOutlineNode createNode(final Key key, final ContentOutlineNode parentNode) {
//		final ContentOutlineNode node = super.newOutlineNode(key, parentNode);
//		node.setLabel(key.getKey());
//		return node;
//	}
	
	public ContentOutlineNode createNode(final SymbolDef symbolDef, final ContentOutlineNode parentNode) {
		final ContentOutlineNode node = super.newOutlineNode(symbolDef, parentNode);
		return node;
	}
}
